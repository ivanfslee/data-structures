//Algorithms and Problem Solving Patterns

//What is an algorithm?
    //a process or set of steps to accomplish a certain task
    //everything in programming involves some kind of algorithm
    //it is the foundation for being a successful problem solver and developer

//Devise a plan to solve algorithms
    //How do you improve?
        //1. Devise a plan for solving problems
        //2. Master common problem solving patterns 

    //IOCE - input/output/constraints/edge cases
    // Step 1 - Understand the problem
    // Step 2 - Explore concrete examples
    // Step 3 - Break it down
    // Step 4 - Solve/simplify
    // Step 5 - Look back and refactor 

//Compare and contrast problem solving patterns 
    //frequency counters
    //two pointer problems
    //divide and conquer

//Step 1 - Understand the problem
    //1. Can i restate the problem in my own words
    //2. What are the inputs that go into problem?
    //3. What are the outputs that should come from the solution to the problem?
    //4. Can the outputs be determined from the inputs? IOW, do I have enough information to solve the problem?
        //You may not be able to answer #4 until you set about solving the problem. Still, the question is worth thinking about at this early stage
    //5. How should I label the important pieces of data that are a part of the problem?

//Step 2 - Explore concrete examples 
    //Write simple examples -their input and their corresponding output 
        //Start with simple examples
        //Progress to more complex examples
        //Explore examples with EMPTY inputs
        //Explore examples with INVALID inputs

//Step 3 - Break it down 
    //Take the actual steps of the problem and write them down
    //Inform the interviewer, your gameplan 
    //Not necessarily pseudocode
    //Broad strokes of your strategy 
    //Explicitly write out the steps you need to take. 
        //This forces you to think about the code you will write before you write it
        //This also helps catch any lingering conceptual isses or misunderstandings before you dive in and worry about details

//Step 4 - Solve/Simplify 
    //If you can't solve the problem, solve a simpler problem/solve simpler part of the problem
    //Solving the simpler part may help you gain insight into the harder parts of the problem
    //Don't just get hung up and spend all your time on the harder part, if there are other parts you could be solving 

    //Simplify
        //Find the core difficulty in what you are trying to do
        //Temporarily ignore that difficulty
        //Write a simplified solution
        //Then incorporate that difficulty back in

//Step 5 - Look back and refactor
    //Efficiency and legibility and maintainability 